/*
Initially auto-generated by: https://github.com/pmndrs/gltfjsx
*/

import React, {
  useRef,
  useState,
  useEffect,
  useCallback,
  useMemo,
  RefObject,
} from 'react';
import { useGLTF } from '@react-three/drei';
import { useSpring, animated, config } from '@react-spring/three';
import * as THREE from 'three';
import * as Tone from 'tone';
import { useThreeDStore } from '../../../stores/threeDStore';
import { useCameraStore } from '../../../stores/cameraStore';
import CircularVisualizer from '../audio/CircularVisualizer';
import { ThreeEvent } from '@react-three/fiber';

// Add this type near the top of the file
type GLTFResult = {
  nodes: {
    [key: string]: THREE.Object3D & {
      geometry?: THREE.BufferGeometry;
      material?: THREE.Material | THREE.Material[];
    };
  };
  materials: {
    [key: string]: THREE.Material;
  };
};

function isMesh(obj: THREE.Object3D): obj is THREE.Mesh {
  return 'geometry' in obj && 'material' in obj;
}

interface ComputerDeskProps {
  position: [number, number, number];
  rotation: [number, number, number];
  scale: [number, number, number];
  audioAnalyser?: Tone.Analyser | null;
  cpuScreenRef: RefObject<THREE.Mesh>;
  onClickStart?: () => void;
}

export const ComputerDesk: React.FC<ComputerDeskProps> = ({
  position,
  rotation,
  scale,
  audioAnalyser,
  cpuScreenRef,
  onClickStart = () => {},
}) => {
  const gltf = useGLTF('/models/computerdesk/computerdesk-v2.glb');
  const { nodes, materials } = gltf as unknown as GLTFResult;
  const { isLampOn, setIsLampOn, speakersPopped, setSpeakersPopped } =
    useCameraStore();
  const lampBulbRef = useRef<THREE.Mesh>();
  const lampLightRef = useRef<THREE.SpotLight>();
  const lampTargetRef = useRef<THREE.Object3D>();
  const { showToneComponent } = useThreeDStore();

  const [isAnimating, setIsAnimating] = useState(false);

  // Initialize springs with [styles, api]
  const [leftSpeakerSpring, leftSpeakerApi] = useSpring(() => ({
    positionY: 26.468,
    rotationX: 0,
    rotationZ: 0,
    config: config.default,
  }));

  const [rightSpeakerSpring, rightSpeakerApi] = useSpring(() => ({
    positionY: 28.939,
    rotationX: 0,
    rotationZ: 0,
    config: config.default,
  }));

  // Function to generate random rotation offsets
  const getRandomRotation = () => {
    const maxRotation = -0.4; // Maximum rotation in radians
    return {
      rotationX: (Math.random() - 0.5) * maxRotation,
      rotationZ: (Math.random() - 0.5) * maxRotation,
    };
  };

  // Function to trigger the speaker animation
  const triggerSpeakerAnimation = useCallback(() => {
    if (isAnimating) {
      console.log('Animation already in progress');
      return;
    }

    console.log('Starting speaker animation');
    setIsAnimating(true);
    setSpeakersPopped(true); // Update speakersPopped state to show visualizer

    const { rotationX: leftRotX, rotationZ: leftRotZ } = getRandomRotation();
    const { rotationX: rightRotX, rotationZ: rightRotZ } = getRandomRotation();

    // Define the jump height
    const jumpHeight = 4;

    // Use existing spring APIs to animate
    const animateLeftSpeaker = leftSpeakerApi.start({
      to: [
        {
          positionY: 26.468 + jumpHeight,
          rotationX: leftRotX,
          rotationZ: leftRotZ,
        },
        { positionY: 26.468, rotationX: 0, rotationZ: 0 },
      ],
      config: { tension: 1300, friction: 30, mass: 0.3 },
    });

    const animateRightSpeaker = rightSpeakerApi.start({
      to: [
        {
          positionY: 28.939 + jumpHeight,
          rotationX: rightRotX,
          rotationZ: rightRotZ,
        },
        { positionY: 28.939, rotationX: 0, rotationZ: 0 },
      ],
      config: { tension: 1300, friction: 30, mass: 0.3 },
    });

    // Once both animations are complete, reset the animating state and speakersPopped
    Promise.all([animateLeftSpeaker, animateRightSpeaker]).then(() => {
      setIsAnimating(false);
      setSpeakersPopped(false);
      console.log('Speaker animation completed, reset speakersPopped');
    });
  }, [isAnimating, leftSpeakerApi, rightSpeakerApi, setSpeakersPopped]);

  // Use effect to trigger animation when speakersPopped changes
  useEffect(() => {
    if (speakersPopped && !isAnimating) {
      console.log('Speakers popped detected, triggering animation');
      triggerSpeakerAnimation();
    }
  }, [speakersPopped, isAnimating, triggerSpeakerAnimation]);

  // Handle pointer down event
  const handlePointerDown = (event: ThreeEvent<MouseEvent>) => {
    event.stopPropagation();
    if (typeof onClickStart === 'function') {
      onClickStart();
    } else {
      console.error('onClickStart is not a function');
    }
    triggerSpeakerAnimation();
  };

  // Toggle Lamp Function
  const toggleLamp = (event: ThreeEvent<MouseEvent>) => {
    event.stopPropagation();
    setIsLampOn(!isLampOn);
  };

  // Create materials for on and off states
  const lampOnMaterial = useMemo(
    () =>
      new THREE.MeshStandardMaterial({
        ...materials.PaletteMaterial002,
        emissive: new THREE.Color(0xffffcc),
        emissiveIntensity: 2,
      }),
    [materials.PaletteMaterial002],
  );

  const lampOffMaterial = useMemo(
    () =>
      new THREE.MeshStandardMaterial({
        color: new THREE.Color(0xcccccc),
        emissive: new THREE.Color(0x000000),
      }),
    [],
  );

  const speakerOnMaterial = useMemo(
    () =>
      new THREE.MeshStandardMaterial({
        ...materials.PaletteMaterial001,
        color: new THREE.Color(0x330000),
        emissive: new THREE.Color(0xff0000),
        emissiveIntensity: 2,
        roughness: 0.3,
        metalness: 0.7,
        opacity: 1,
        side: THREE.FrontSide,
      }),
    [materials.PaletteMaterial001],
  );

  const speakerOffMaterial = useMemo(
    () =>
      new THREE.MeshStandardMaterial({
        ...materials.PaletteMaterial001,
        color: new THREE.Color(0x330000),
        emissive: new THREE.Color(0x330000),
        emissiveIntensity: 0,
        roughness: 0.7,
        metalness: 0.5,
        opacity: 1,
        side: THREE.FrontSide,
      }),
    [materials.PaletteMaterial001],
  );

  // Create quaternions for on and off states
  const onQuaternion = useMemo(
    () =>
      new THREE.Quaternion().setFromEuler(
        new THREE.Euler(-1.697, 0.236, 2.066),
      ),
    [],
  );
  const offQuaternion = useMemo(
    () =>
      new THREE.Quaternion()
        .setFromEuler(new THREE.Euler(-1.697, 0.236, 2.066))
        .multiply(
          new THREE.Quaternion().setFromAxisAngle(
            new THREE.Vector3(-1, 0, 0),
            Math.PI / 6,
          ),
        ),
    [],
  );

  // Animation for the lamp switch
  const { quaternion } = useSpring({
    quaternion: isLampOn ? onQuaternion : offQuaternion,
    config: { mass: 1, tension: 180, friction: 12 },
  });

  // Update light target when the component updates
  React.useEffect(() => {
    if (lampLightRef.current && lampTargetRef.current) {
      lampLightRef.current.target = lampTargetRef.current;
    }
  }, []);

  return (
    <group position={position} rotation={rotation} scale={scale} dispose={null}>
      {/* Left Speaker */}
      <animated.group
        position-y={leftSpeakerSpring.positionY}
        rotation-x={leftSpeakerSpring.rotationX}
        rotation-z={leftSpeakerSpring.rotationZ}
        position-x={6.131}
        position-z={4.565}
      >
        <mesh
          castShadow
          receiveShadow
          geometry={nodes.L_SpeakerLight.geometry}
          material={showToneComponent ? speakerOnMaterial : speakerOffMaterial}
          rotation={[-1.557, -0.069, 1.763]}
          scale={2}
        />
        <mesh
          castShadow
          receiveShadow
          geometry={nodes.L_SpeakerMesh.geometry}
          material={materials.baked}
          rotation={[-1.557, -0.069, 1.863]}
          scale={2}
          onClick={(e: ThreeEvent<MouseEvent>) => handlePointerDown(e)}
        />
        {speakersPopped && (
          <CircularVisualizer position={[0, 0, 1]} scale={0.5} />
        )}
      </animated.group>
      {/* Right Speaker */}
      <animated.group
        position-y={rightSpeakerSpring.positionY}
        rotation-x={rightSpeakerSpring.rotationX}
        rotation-z={rightSpeakerSpring.rotationZ}
        position-x={4.527}
        position-z={-11.458}
      >
        <mesh
          castShadow
          receiveShadow
          geometry={nodes.R_SpeakerLight.geometry}
          material={showToneComponent ? speakerOnMaterial : speakerOffMaterial}
          rotation={[-1.582, -0.069, 1.413]}
          scale={2}
        />
        <mesh
          castShadow
          receiveShadow
          geometry={nodes.R_SpeakerMesh.geometry}
          material={materials.baked}
          rotation={[-1.582, -0.069, 1.283]}
          scale={2}
          onClick={(e: ThreeEvent<MouseEvent>) => handlePointerDown(e)}
        />
        {speakersPopped && (
          <CircularVisualizer position={[0, 0, 1]} scale={0.5} />
        )}
      </animated.group>
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.L_SpeakerCable.geometry}
        material={materials.PaletteMaterial001}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.L_SpeakerPlug.geometry}
        material={materials.PaletteMaterial001}
        position={[2.519, 27.263, -10.693]}
        rotation={[-0.28, -0.092, 1.544]}
        scale={25}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.R_SpeakerCable.geometry}
        material={materials.PaletteMaterial001}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.R_SpeakerPlug.geometry}
        material={materials.PaletteMaterial001}
        position={[2.569, 27.214, 13.514]}
        rotation={[-0.297, 0.224, 1.705]}
        scale={25}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.SpeakerAUX.geometry}
        material={materials.PaletteMaterial001}
        position={[3.936, 32.082, 7.204]}
        rotation={[0, 0, -Math.PI / 2]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.CPU_Cables.geometry}
        material={materials.default_1007}
        position={[-2.405, 26.688, 0.609]}
        rotation={[-Math.PI / 2, 0, Math.PI / 2]}
        scale={[0.048, 0.046, 0.046]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.CPU_Keyboard.geometry}
        material={materials.default_1006}
        position={[-2.36, 26.75, 0.66]}
        rotation={[-Math.PI / 2, 0, Math.PI / 2]}
        scale={[0.048, 0.046, 0.046]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.CPU_Part1.geometry}
        material={materials.default_1001}
        position={[-2.36, 26.75, 0.66]}
        rotation={[-Math.PI / 2, 0, Math.PI / 2]}
        scale={[0.048, 0.046, 0.046]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.CPU_Part2.geometry}
        material={materials.default_1005}
        position={[-2.36, 26.75, 0.66]}
        rotation={[-Math.PI / 2, 0, Math.PI / 2]}
        scale={[0.048, 0.046, 0.046]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.CPU_Part3.geometry}
        material={materials.default_1002}
        position={[-2.36, 26.75, 0.66]}
        rotation={[-Math.PI / 2, 0, Math.PI / 2]}
        scale={[0.048, 0.046, 0.046]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.CPU_Part4.geometry}
        material={materials.default_1004}
        position={[-2.36, 26.75, 0.66]}
        rotation={[-Math.PI / 2, 0, Math.PI / 2]}
        scale={[0.048, 0.046, 0.046]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.CPU_Part5.geometry}
        material={materials.default_1003}
        position={[-2.36, 26.75, 0.66]}
        rotation={[-Math.PI / 2, 0, Math.PI / 2]}
        scale={[0.048, 0.046, 0.046]}
      />
      <mesh
        ref={cpuScreenRef}
        castShadow
        receiveShadow
        geometry={nodes.CPU_Screen.geometry}
        material={materials.default_1003}
        position={[-2.36, 26.75, 0.66]}
        rotation={[-Math.PI / 2, 0, Math.PI / 2]}
        scale={[0.048, 0.046, 0.046]}
        //        onPointerDown={handlePointerDown} // Use pointer event
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Mouse.geometry}
        material={materials.default_1002}
        position={[-2.36, 26.75, 0.66]}
        rotation={[-Math.PI / 2, 0, Math.PI / 2]}
        scale={[0.048, 0.046, 0.046]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Desk.geometry}
        material={materials['21___Default']}
        position={[9.6, 0, 0]}
        scale={[0.04, 0.035, 0.035]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Mousepad.geometry}
        material={materials.PaletteMaterial001}
        position={[9.501, 26.857, -19.809]}
      />
      <mesh
        geometry={nodes.Chair.geometry}
        material={materials['21___Default']}
        position={[38.42, 12.467, 16.424]}
        rotation={[-Math.PI / 2, 0, -2.477]}
        scale={[0.31, 0.31, 0.32]}
      />
      <mesh
        geometry={nodes.Cushion.geometry}
        material={materials.PaletteMaterial001}
        position={[37.713, 17.689, 15.581]}
        rotation={[Math.PI / 2, 0, -0.655]}
        scale={[8.931, 8.931, 8.739]}
      />
      <mesh
        ref={lampBulbRef}
        geometry={nodes.LampBulb.geometry}
        material={isLampOn ? lampOnMaterial : lampOffMaterial}
        position={[-4.456, 39.895, 22.395]}
        rotation={[-1.424, -0.273, 2.071]}
        scale={2.165}
        onClick={(e: ThreeEvent<MouseEvent>) => toggleLamp(e)}
      >
        <spotLight
          ref={lampLightRef}
          position={[0.001, -0.2, -0.001]}
          intensity={isLampOn ? 120 : 0}
          angle={Math.PI / 5.5}
          penumbra={0.7}
          distance={50}
          decay={1}
          color={0xffffcc}
          shadow-mapSize-width={1024}
          shadow-mapSize-height={1024}
          shadow-bias={-0.001}
        />
      </mesh>
      {/* Light target */}
      <object3D
        ref={lampTargetRef}
        position={[0, 27.5, 20]} // Adjust this position to change where the light points
      />
      <animated.mesh
        castShadow
        receiveShadow
        geometry={nodes.LampOnOff.geometry}
        material={materials['Material.005']}
        position={[-4.689, 28.286, 22.516]}
        quaternion={quaternion}
        scale={[0.245, 0.407, 0.151]}
        onClick={(e: ThreeEvent<MouseEvent>) => toggleLamp(e)}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.LampSocket.geometry}
        material={materials.PaletteMaterial003}
        position={[-4.456, 39.895, 22.395]}
        rotation={[-1.424, -0.273, 2.071]}
        scale={2.165}
        onClick={(e: ThreeEvent<MouseEvent>) => toggleLamp(e)}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.LampStand.geometry}
        material={materials['Material.004']}
        position={[-6.736, 27.913, 23.583]}
        rotation={[-Math.PI / 2, 0, 2.051]}
        scale={2.165}
        onClick={(e: ThreeEvent<MouseEvent>) => toggleLamp(e)}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.LampTop.geometry}
        material={materials['Material.004']}
        position={[-4.456, 39.895, 22.395]}
        rotation={[-1.424, -0.273, 2.071]}
        scale={2.165}
        onClick={(e: ThreeEvent<MouseEvent>) => toggleLamp(e)}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.LampTube.geometry}
        material={materials['Material.005']}
        position={[-6.651, 26.414, 23.538]}
        rotation={[-Math.PI / 2, 0, 2.051]}
        scale={2.165}
        onClick={(e: ThreeEvent<MouseEvent>) => toggleLamp(e)}
      />
    </group>
  );
};

export default ComputerDesk;

useGLTF.preload('/models/computerdesk/computerdesk-v2.glb');
